on:
  push:
    branches:
      - calico-win-manifests

jobs:
  build-k0s:
    strategy:
      matrix:
        target-os: [linux, windows]

    name: "Build :: k0s :: ${{ matrix.target-os }}-amd64"
    uses: ./.github/workflows/build-k0s.yml
    with:
      target-os: ${{ matrix.target-os }}
      target-arch: amd64

  smoketest:
    name: Smoketest
    needs: [build-k0s]

    runs-on: windows-2022

    steps:
      - name: "Build :: Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # for `git describe`
          persist-credentials: false

      # - name: Pre-create HNS networking
      #   run: |
      #     $ErrorActionPreference = "Stop"
      #     $PSNativeCommandUseErrorActionPreference = $true

      #     # Download the MS helpers and load them
      #     $u = "https://raw.githubusercontent.com/Microsoft/SDN/master/Kubernetes/windows/hns.psm1"
      #     Invoke-WebRequest -Uri $u -OutFile c:/hns.psm1
      #     Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass -Force
      #     Unblock-File 'C:\hns.psm1'            # removes the "downloaded from internet" mark
      #     Import-Module 'C:\hns.psm1' -Force


      #     Write-Host "Creating overlay network"
      #     New-HnsNetwork -Type "Overlay" -AddressPrefix "192.168.255.0/30" -Gateway "192.168.255.1" -Name "External" -SubnetPolicies @(@{Type = "VSID"; VSID = 9999; }) -Verbose
      #     Start-Sleep -s 20s
      #     Write-Host "Overlay network created succesfully"

      #     # Write-Host "Creating bridge network"
      #     # New-HnsNetwork -Type "L2Bridge" -AddressPrefix "10.244.10.0/24" -Gateway "10.244.10.1" -Name "External" -Verbose
      #     # Start-Sleep -s 20s
      #     # Write-Host "Bridge network created succesfully"

      - name: Configure WSL to NOT do local port forwarding
        run: |
          @"
          [wsl2]
          localhostForwarding=false
          networkingMode=nat
          "@ | Out-File -FilePath "$env:UserProfile\.wslconfig" -Encoding ascii
      - name: Prepare WSL
        run: |
          $ErrorActionPreference = "Stop"
          $PSNativeCommandUseErrorActionPreference = $true

          & Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False

          Write-Host "Updating to WSL 2 ..."
          & wsl --set-default-version 2
          & wsl --update

          Write-Host "Downloading Ubuntu WSL ..."
          Invoke-WebRequest -Uri https://old-releases.ubuntu.com/releases/24.04.2/ubuntu-24.04.2-wsl-amd64.wsl -OutFile ubuntu.wsl
          Write-Host "Importing Ubuntu WSL ..."
          New-Item -ItemType Directory -Path .\ubuntu | Out-Null
          & wsl --import Ubuntu .\ubuntu .\ubuntu.wsl
                    Write-Host "Launching WSL ..."
          & wsl -l

          # https://github.com/microsoft/WSL/issues/10138#issuecomment-2380431569
          @'
          [Unit]
          Description=A simple service to keep WSL alive
          Documentation=https://github.com/gardengim/keepwsl

          [Service]
          ExecStart=/mnt/c/Windows/System32/wsl.exe sleep infinity
          Restart=always

          [Install]
          WantedBy=default.target
          # some trailing carriage return
          '@ | & wsl tee /etc/systemd/system/keepwsl.service | Out-Null

          & wsl -- base64 /etc/systemd/system/keepwsl.service

          & wsl -- systemctl daemon-reload
          & wsl -- systemctl start keepwsl.service

      - name: Persistent port forwards win -> WSL
        run: |
          $ErrorActionPreference = "Stop"

          # Find WSL IP
          $wslIP = (wsl.exe -e sh -lc "hostname -I | cut -f 1 -d ' '").Trim()

          # Find the IP of the primary interface to bind stuff to
          $dest = '8.8.8.8'
          $best = Find-NetRoute -RemoteIPAddress $dest | Select-Object -First 1
          $nodeIP = (Get-NetIPAddress -InterfaceIndex $best.InterfaceIndex -AddressFamily IPv4).IPAddress
          Write-Host "Found primary IP of the runner: $nodeIP"

          # Map Windows localhost ports â†’ WSL ports
          foreach ($p in 6443,8132) {
            netsh interface portproxy delete v4tov4 listenaddress=$nodeIP listenport=$p 2>$null
            netsh interface portproxy add    v4tov4 listenaddress=$nodeIP listenport=$p connectport=$p connectaddress=$wslIP
          }

          # Show what we have
          netsh interface portproxy show v4tov4

          # Put node and WSL IPs to GH env
          "NODE_IP=$nodeIP" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "WSL_IP=$wslIP" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Download compiled binaries
        uses: actions/download-artifact@v4
        with:
          pattern: k0s-{linux,windows}-amd64
          merge-multiple: true

      - name: Install and start k0s controller
        id: start-controller
        run: |
          $ErrorActionPreference = "Stop"
          $PSNativeCommandUseErrorActionPreference = $true

          & ./k0s.exe version

          $dir = Resolve-Path .
          $dir = "/mnt/$((Split-Path -Qualifier $dir).ToLower()[0])$((Split-Path -NoQualifier $dir) -replace '\\','/')"

          @"
          mkdir /etc/k0s
          cat <<EOF >/etc/k0s/k0s.yaml
          spec:
            api:
              address: ${env:NODE_IP}
              sans:
                - ${env:WSL_IP}
                - ${env:NODE_IP}
            storage:
              type: kine
            network:
              provider: calico
            images:
              pause:
                # FIXME We need to use the upstream pause image here since the
                # k0sproject's one doesn't ship with a windows build currently.
                image: k8s.gcr.io/pause
                version: 3.10.1
          EOF

          install -m755 -D -- '$dir/k0s' /usr/local/bin/k0s

          k0s install controller --debug --enable-worker --disable-components metrics-server
          # Do not use "k0s start" here, as its error reporting is poor.
          systemctl start k0scontroller.service
          # some trailing carriage return
          "@ -replace "`r`n", "`n" | & wsl bash -euo pipefail

          # Wait that we get connection to the kube api on WSL IP
          
      - name: Prepare kubeconfig
        run: |
          $ErrorActionPreference = "Stop"
          $PSNativeCommandUseErrorActionPreference = $true

          for ($attempt = 1; $true; $attempt++) {
            try {
              Write-Host "Getting kubeconfig (attempt $attempt) ..."
              & wsl k0s kubeconfig admin | Out-File -FilePath kubeconfig -Encoding utf8
            }
            catch {
              if ($attempt -gt 5) {
                throw
              }

              Write-Warning "Failed to get kubeconfig: $_"
              & wsl -- systemctl status k0scontroller.service
              Start-Sleep -Seconds 5
              continue
            }

            Write-Host "Kubeconfig written to file"
            break
          }

          "KUBECONFIG=" + (Resolve-Path "kubeconfig").Path | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Wait for kube api
        run: |
          for ($attempt = 1; $true; $attempt++) {
            try {
              Write-Host "Verifying kube API access (attempt $attempt) ..."
              & kubectl get nodes
            }
            catch {
              if ($attempt -gt 15) {
                throw
              }

              Write-Warning "Failed to access API: $_"
              & wsl -- systemctl status k0scontroller.service
              Start-Sleep -Seconds 5
              continue
            }

            Write-Host "API access verified successfully"
            break
          }

      - name: Get join token
        run: |
          $ErrorActionPreference = "Stop"
          $PSNativeCommandUseErrorActionPreference = $true

          for ($attempt = 1; $true; $attempt++) {
            try {
              Write-Host "Getting join token (attempt $attempt) ..."
              & wsl k0s token create --role=worker | Out-File -FilePath k0s-worker-token -Encoding utf8
            }
            catch {
              if ($attempt -gt 15) {
                throw
              }

              Write-Warning "Failed to get join token: $_"
              & wsl -- systemctl status k0scontroller.service
              Start-Sleep -Seconds 5
              continue
            }

            Write-Host "Join token written to file"
            break
          }

      # Calico borks network when it creates the HNS network etc. so we need to have a watchdog that restores route to WSL
      # - name: Start route watchdog (Scheduled Task)
      #   shell: pwsh
      #   run: |
      #     $ErrorActionPreference = 'Stop'

      #     $taskName = 'WSLRouteWatchdog'
      #     $script   = Join-Path $env:GITHUB_WORKSPACE 'route-watchdog.ps1'   # repo root
      #     $log      = Join-Path $env:RUNNER_TEMP 'route-watchdog.log'
      #     $minutes  = 10    # how long to keep the watchdog alive
      #     $port     = 6443  # apiserver port it protects

      #     # Build a tiny PS payload for the task:
      #     # - sets any env you want in the task's process (optional)
      #     # - calls your script with -Minutes, -Port, -LogFile
      #     $payload = @"
      #     `$ErrorActionPreference = 'Stop'
      #     `$env:KUBECONFIG = "$env:KUBECONFIG"
      #     & "$script" -Minutes $minutes -LogFile "$log"
      #     "@

      #     $encoded = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($payload))

      #     $action    = New-ScheduledTaskAction  -Execute 'pwsh.exe' -Argument "-NoProfile -ExecutionPolicy Bypass -EncodedCommand $encoded"
      #     $principal = New-ScheduledTaskPrincipal -UserId 'SYSTEM' -RunLevel Highest
      #     $trigger   = New-ScheduledTaskTrigger -Once -At (Get-Date).AddSeconds(5)
      #     # Give it ample time; it will naturally exit when your script finishes
      #     $settings  = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries `
      #                 -ExecutionTimeLimit (New-TimeSpan -Hours 1)

      #     Register-ScheduledTask -TaskName $taskName -Action $action -Principal $principal -Trigger $trigger -Settings $settings -Force | Out-Null
      #     Start-ScheduledTask    -TaskName $taskName

      #     # Make paths available to later steps
      #     "WATCHDOG_TASK=$taskName" | Out-File -FilePath $env:GITHUB_ENV -Append
      #     "WATCHDOG_LOG=$log"      | Out-File -FilePath $env:GITHUB_ENV -Append

      #     Write-Host "Watchdog task '$taskName' started. Log: $log"
        
      - name: Install & Start k0s worker
        run: |
          & .\k0s.exe install worker --token-file=k0s-worker-token --debug --kubelet-extra-args="--hostname-override=windowsworker"
          & .\k0s.exe start
      # - name: Windows smoke test
      #   timeout-minutes: 5
      #   run: |
      #     & kubectl config view
      #     & kubectl get nodes,pods -A
      #     go test ./inttest/windows -v

      # Watch the state of the cluster in loop
      - name: Cluster state
        timeout-minutes: 15
        run: |
          $ErrorActionPreference = "Continue"
          $PSNativeCommandUseErrorActionPreference = $false

          Write-Host "Watching cluster state for a while ..."
          for ($i = 0; $i -lt 60; $i++) {
            $ts = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
            Write-Host "`n=== $ts ==="
            Write-Host "-- HNS networks"
            Get-HnsNetwork
            Write-Host "-- port forwards"
            netsh interface portproxy show v4tov4
            # Check if the needed ports are open, if not re-create
            Write-Host "-- cluster state"
            try {
              & kubectl get nodes,pods -A -o wide | Out-Host
              if ($LASTEXITCODE -ne 0) {
                throw "kubectl exited with code $LASTEXITCODE"
              }
            } catch {
              Write-Host "Error getting cluster state: $_"
              Write-Host "Restarting k0scontroller systemd unit on WSL..."
              & wsl -- systemctl restart k0scontroller.service
            }
            Write-Host "-- WSL k0s state"
            wsl.exe k0s kc get node,pod -A -o wide

            Start-Sleep -Seconds 5
          }

      - name: Upload k0s & container logs
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: containers-logs
          path: |
            c:/var/lib/k0s/k0s_*.log
            c:/var/log/**/*


      - name: Monitor cluster a bit
        run: |
          $ErrorActionPreference = "Stop"
          $PSNativeCommandUseErrorActionPreference = $true

          for ($attempt = 1; $attempt -le 5; $attempt++) {
            try {
              & kubectl get node,po -A -owide
            }
            catch {
              if ($attempt -eq 5 ) {
                throw
              }
              & wsl -- systemctl status k0scontroller.service
            }
            Start-Sleep -Seconds 5
          }

      - name: k0s controller logs
        if: failure() && steps.start-controller.conclusion == 'success'
        run: |
          & Get-CimInstance Win32_LogicalDisk -Filter "DriveType=3" | 
              Select-Object DeviceID, VolumeName,
              @{n='FreeGB';e={[math]::Round($_.FreeSpace/1GB,2)}},
              @{n='TotalGB';e={[math]::Round($_.Size/1GB,2)}},
              @{n='%Free';e={[math]::Round(100*$_.FreeSpace/$_.Size,1)}}
          & wsl hostname -I
          & wsl nproc
          & wsl free -h
          & wsl df -h
          & wsl systemctl status k0scontroller.service
          & wsl journalctl --boot -u k0scontroller.service
