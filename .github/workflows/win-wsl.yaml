on:
  push:
    branches:
      - calico-win-manifests

jobs:
  build-k0s:
    strategy:
      matrix:
        target-os: [linux, windows]

    name: "Build :: k0s :: ${{ matrix.target-os }}-amd64"
    uses: ./.github/workflows/build-k0s.yml
    with:
      target-os: ${{ matrix.target-os }}
      target-arch: amd64

  smoketest:
    name: Smoketest
    needs: [build-k0s]

    runs-on: windows-2022

    steps:
      - name: "Build :: Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # for `git describe`
          persist-credentials: false
      - name: Configure WSL to NOT do local port forwarding
        run: |
          @"
          [wsl2]
          localhostForwarding=false
          "@ | Out-File -FilePath "$env:UserProfile\.wslconfig" -Encoding ascii
      - name: Prepare WSL
        run: |
          $ErrorActionPreference = "Stop"
          $PSNativeCommandUseErrorActionPreference = $true

          & Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False

          Write-Host "Updating to WSL 2 ..."
          & wsl --set-default-version 2
          & wsl --update

          Write-Host "Downloading Ubuntu WSL ..."
          Invoke-WebRequest -Uri https://old-releases.ubuntu.com/releases/24.04.2/ubuntu-24.04.2-wsl-amd64.wsl -OutFile ubuntu.wsl
          Write-Host "Importing Ubuntu WSL ..."
          New-Item -ItemType Directory -Path .\ubuntu | Out-Null
          & wsl --import Ubuntu .\ubuntu .\ubuntu.wsl
          Write-Host "Launching WSL ..."
          & wsl -l

          # https://github.com/microsoft/WSL/issues/10138#issuecomment-2380431569
          @'
          [Unit]
          Description=A simple service to keep WSL alive
          Documentation=https://github.com/gardengim/keepwsl

          [Service]
          ExecStart=/mnt/c/Windows/System32/wsl.exe sleep infinity
          Restart=always

          [Install]
          WantedBy=default.target
          # some trailing carriage return
          '@ | & wsl tee /etc/systemd/system/keepwsl.service | Out-Null

          & wsl -- base64 /etc/systemd/system/keepwsl.service

          & wsl -- systemctl daemon-reload
          & wsl -- systemctl start keepwsl.service

      - name: Download compiled binaries
        uses: actions/download-artifact@v4
        with:
          pattern: k0s-{linux,windows}-amd64
          merge-multiple: true

      - name: Install and start k0s controller
        id: start-controller
        run: |
          $ErrorActionPreference = "Stop"
          $PSNativeCommandUseErrorActionPreference = $true

          & ./k0s.exe version

          $dir = Resolve-Path .
          $dir = "/mnt/$((Split-Path -Qualifier $dir).ToLower()[0])$((Split-Path -NoQualifier $dir) -replace '\\','/')"

          @"
          mkdir /etc/k0s
          cat <<EOF >/etc/k0s/k0s.yaml
          spec:
            storage:
              type: kine
            network:
              provider: calico
            images:
              pause:
                # FIXME We need to use the upstream pause image here since the
                # k0sproject's one doesn't ship with a windows build currently.
                image: k8s.gcr.io/pause
                version: 3.10.1
          EOF

          install -m755 -D -- '$dir/k0s' /usr/local/bin/k0s

          k0s install controller --debug --enable-worker --disable-components metrics-server
          # Do not use "k0s start" here, as its error reporting is poor.
          systemctl start k0scontroller.service
          # some trailing carriage return
          "@ -replace "`r`n", "`n" | & wsl bash -euo pipefail

          # Wait that we get connection to the kube api on WSL IP
          
      - name: Prepare kubeconfig
        run: |
          $ErrorActionPreference = "Stop"
          $PSNativeCommandUseErrorActionPreference = $true

          for ($attempt = 1; $true; $attempt++) {
            try {
              Write-Host "Getting kubeconfig (attempt $attempt) ..."
              & wsl k0s kubeconfig admin | Out-File -FilePath kubeconfig -Encoding utf8
            }
            catch {
              if ($attempt -gt 5) {
                throw
              }

              Write-Warning "Failed to get kubeconfig: $_"
              & wsl -- systemctl status k0scontroller.service
              Start-Sleep -Seconds 5
              continue
            }

            Write-Host "Kubeconfig written to file"
            break
          }

          "KUBECONFIG=" + (Resolve-Path "kubeconfig").Path | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Wait for kube api
        run: |
          for ($attempt = 1; $true; $attempt++) {
            try {
              Write-Host "Verifying kube API access (attempt $attempt) ..."
              & kubectl get nodes
            }
            catch {
              if ($attempt -gt 15) {
                throw
              }

              Write-Warning "Failed to access API: $_"
              & wsl -- systemctl status k0scontroller.service
              Start-Sleep -Seconds 5
              continue
            }

            Write-Host "API access verified successfully"
            break
          }

      - name: Get join token
        run: |
          $ErrorActionPreference = "Stop"
          $PSNativeCommandUseErrorActionPreference = $true

          for ($attempt = 1; $true; $attempt++) {
            try {
              Write-Host "Getting join token (attempt $attempt) ..."
              & wsl k0s token create --role=worker | Out-File -FilePath k0s-worker-token -Encoding utf8
            }
            catch {
              if ($attempt -gt 15) {
                throw
              }

              Write-Warning "Failed to get join token: $_"
              & wsl -- systemctl status k0scontroller.service
              Start-Sleep -Seconds 5
              continue
            }

            Write-Host "Join token written to file"
            break
          }

      # Calico borks network when it creates the HNS network etc. so we need to have a watchdog that restores route to WSL
      # - name: Start route watchdog (Scheduled Task)
      #   shell: pwsh
      #   run: |
      #     $ErrorActionPreference = 'Stop'

      #     $taskName = 'WSLRouteWatchdog'
      #     $script   = Join-Path $env:GITHUB_WORKSPACE 'route-watchdog.ps1'   # repo root
      #     $log      = Join-Path $env:RUNNER_TEMP 'route-watchdog.log'
      #     $minutes  = 10    # how long to keep the watchdog alive
      #     $port     = 6443  # apiserver port it protects

      #     # Build a tiny PS payload for the task:
      #     # - sets any env you want in the task's process (optional)
      #     # - calls your script with -Minutes, -Port, -LogFile
      #     $payload = @"
      #     `$ErrorActionPreference = 'Stop'
      #     `$env:KUBECONFIG = "$env:KUBECONFIG"
      #     & "$script" -Minutes $minutes -LogFile "$log"
      #     "@

      #     $encoded = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($payload))

      #     $action    = New-ScheduledTaskAction  -Execute 'pwsh.exe' -Argument "-NoProfile -ExecutionPolicy Bypass -EncodedCommand $encoded"
      #     $principal = New-ScheduledTaskPrincipal -UserId 'SYSTEM' -RunLevel Highest
      #     $trigger   = New-ScheduledTaskTrigger -Once -At (Get-Date).AddSeconds(5)
      #     # Give it ample time; it will naturally exit when your script finishes
      #     $settings  = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries `
      #                 -ExecutionTimeLimit (New-TimeSpan -Hours 1)

      #     Register-ScheduledTask -TaskName $taskName -Action $action -Principal $principal -Trigger $trigger -Settings $settings -Force | Out-Null
      #     Start-ScheduledTask    -TaskName $taskName

      #     # Make paths available to later steps
      #     "WATCHDOG_TASK=$taskName" | Out-File -FilePath $env:GITHUB_ENV -Append
      #     "WATCHDOG_LOG=$log"      | Out-File -FilePath $env:GITHUB_ENV -Append

      #     Write-Host "Watchdog task '$taskName' started. Log: $log"
        
      - name: Install & Start k0s worker
        run: |
          & .\k0s.exe install worker --token-file=k0s-worker-token --debug --kubelet-extra-args="--hostname-override=windowsworker"
          & .\k0s.exe start
      # - name: Windows smoke test
      #   timeout-minutes: 5
      #   run: |
      #     & kubectl config view
      #     & kubectl get nodes,pods -A
      #     go test ./inttest/windows -v

      # Watch the state of the cluster in loop
      - name: Debug 
        timeout-minutes: 5
        if: always()
        run: |
          $ErrorActionPreference = "Continue"
          $PSNativeCommandUseErrorActionPreference = $false
          & wsl hostname -I
          & wsl df -h
          & wsl free -h
          & wsl nproc
          $interval = 5      # seconds
          $minutes  = 5
          $end = (Get-Date).AddMinutes($minutes)

          $wslIP = wsl.exe -e sh -lc "hostname -I | cut -f 1 -d ' '" | Out-String
          $wslIP = $wslIP.Trim()
          Write-Host "WSL IP: $wslIP"
          $wslRoute = Find-NetRoute -RemoteIPAddress $wslIP -ErrorAction SilentlyContinue
          Write-Host "Got initial WSL route, interface: $($wslRoute.InterfaceIndex), next hop: $($wslRoute.NextHop)"
          $defaultRoute = Find-NetRoute -RemoteIPAddress 1.1.1.1 -ErrorAction SilentlyContinue
          Write-Host "Got initial default route, interface: $($defaultRoute.InterfaceIndex), next hop: $($defaultRoute.NextHop)"

          Write-Host "Watching cluster for $minutes minutes (every $interval s)..."
          while ((Get-Date).CompareTo($end) -lt 0) {
            $ts = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
            Write-Host "`n=== $ts ==="

            # API server quick health
            kubectl get --raw /readyz

            kubectl get nodes,pods -A -o wide | Out-Host
            Write-Host "`n=== routing ==="
            route PRINT

            # If default or WSL routes disappear, re-create them
            $wr = Find-NetRoute -RemoteIPAddress "$wslIP/32" -ErrorAction SilentlyContinue
            if (-not $wr) {
              Write-Host "Re-creating WSL route..."
              New-NetRoute -DestinationPrefix "$wslIP/32" -InterfaceIndex $wslRoute.InterfaceIndex -NextHop $wslRoute.NextHop -RouteMetric 1 -PolicyStore PersistentStore -ErrorAction Stop
            }
            $dr = Find-NetRoute -RemoteIPAddress 1.1.1.1 -ErrorAction SilentlyContinue
            if (-not $dr) {
              Write-Host "Re-creating default route..."
              New-NetRoute -DestinationPrefix "0.0.0.0/0" -InterfaceIndex $defaultRoute.InterfaceIndex -NextHop $defaultRoute.NextHop -RouteMetric 1 -PolicyStore PersistentStore -ErrorAction Stop
            }

            Start-Sleep -Seconds $interval
          }

      # - name: Stop route watchdog & show log
      #   if: always()
      #   shell: pwsh
      #   run: |
      #     $tn = $env:WATCHDOG_TASK
      #     if ($tn) {
      #       Stop-ScheduledTask -TaskName $tn -ErrorAction SilentlyContinue
      #       Start-Sleep 1
      #       Unregister-ScheduledTask -TaskName $tn -Confirm:$false -ErrorAction SilentlyContinue
      #     }

      #     if ($env:WATCHDOG_LOG -and (Test-Path $env:WATCHDOG_LOG)) {
      #       Write-Host "`n--- tail of watchdog log ---"
      #       Get-Content $env:WATCHDOG_LOG
      #     }

      - name: Grap everything from /var/log/containers on Windows
        if: failure()
        run: |
          $ErrorActionPreference = 'Stop'

          # Prefer pods dir; fall back to containers
          $roots = @('C:\var\log\pods','C:\var\log\containers') | Where-Object { Test-Path $_ }
          if (-not $roots) {
            Write-Warning "No C:\var\log\pods or C:\var\log\containers found on this runner."
            $roots = @()
          }

          # Make sure we write into a known-good location
          $outDir = $env:RUNNER_TEMP
          if (-not (Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir -Force | Out-Null }
          $dst = Join-Path $outDir 'containers-logs.zip'

          if ($roots.Count -eq 0) {
            # Always produce an artifact so upload succeeds (even if empty)
            "No log directories present." | Out-File (Join-Path $outDir 'NO_LOGS.txt')
            tar -a -c -f $dst -C $outDir NO_LOGS.txt
          } else {
            # Use 'pods' if present to avoid symlink weirdness under 'containers'
            $root = if (Test-Path 'C:\var\log\pods') { 'C:\var\log\pods' } else { 'C:\var\log\containers' }

            # Give a little visibility in the action logs
            Write-Host "Archiving from: $root"
            Get-ChildItem -Path $root -Recurse -File -ErrorAction SilentlyContinue | 
              Select-Object -First 10 FullName | ForEach-Object { "  sample: $_" }

            # Create the zip. 'tar -a' is generally sturdier than Compress-Archive on Windows.
            tar -a -c -f $dst -C (Split-Path $root) (Split-Path $root -Leaf)

            # Prove the file exists + show size
            if (-not (Test-Path $dst)) { throw "Archive not created at $dst" }
            $size = (Get-Item $dst).Length
            Write-Host "Wrote $dst ($([math]::Round($size/1MB,2)) MB)"
          }

      - name: Upload k0s & container logs
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: containers-logs
          path: |
            c:/var/lib/k0s/k0s_*.log
            ${{ runner.temp }}\containers-logs.zip


      - name: Monitor cluster a bit
        run: |
          $ErrorActionPreference = "Stop"
          $PSNativeCommandUseErrorActionPreference = $true

          for ($attempt = 1; $attempt -le 5; $attempt++) {
            try {
              & kubectl get node,po -A -owide
            }
            catch {
              if ($attempt -eq 5 ) {
                throw
              }
              & wsl -- systemctl status k0scontroller.service
            }
            Start-Sleep -Seconds 5
          }

      - name: k0s controller logs
        if: failure() && steps.start-controller.conclusion == 'success'
        run: |
          & Get-CimInstance Win32_LogicalDisk -Filter "DriveType=3" | 
              Select-Object DeviceID, VolumeName,
              @{n='FreeGB';e={[math]::Round($_.FreeSpace/1GB,2)}},
              @{n='TotalGB';e={[math]::Round($_.Size/1GB,2)}},
              @{n='%Free';e={[math]::Round(100*$_.FreeSpace/$_.Size,1)}}
          & wsl hostname -I
          & wsl nproc
          & wsl free -h
          & wsl df -h
          & wsl systemctl status k0scontroller.service
          & wsl journalctl --boot -u k0scontroller.service
